# <div align="center">NoSQL Injection</div>
**NoSQL injection** is a type of security vulnerability that happens when an attacker can manipulate the way an application talks to a NoSQL database. This kind of injection can be dangerous because it lets attackers interfere with database queries in unexpected ways.

With NoSQL injection, an attacker might be able to:

* Bypass login systems or security checks
* View, change, or delete data they shouldn’t have access to
* Crash the system and cause downtime (denial of service)
* In some cases, even run malicious code on the server

Unlike traditional SQL databases (like MySQL or PostgreSQL), **NoSQL databases** don’t use the standard SQL language. They store data in different formats (like JSON or key-value pairs) and have more flexible, but less strict, query structures—making them a bit trickier to secure if developers aren’t careful.

![nosql-injection-graphic](https://github.com/user-attachments/assets/8f6936cd-2fea-443c-bd8b-a7a40d16b5ee)

There are **two main types** of NoSQL injection attacks you should know about:

#### 1. **Syntax Injection**

This happens when an attacker is able to **break or modify the structure** of a NoSQL query to insert their own malicious code. It’s somewhat similar to traditional SQL injection in concept, but since NoSQL databases use different query formats and data structures, the actual attack methods can vary quite a bit.

* **Example:** Injecting custom JSON objects into a query to change how it behaves.

#### 2. **Operator Injection**

In this case, the attacker uses **NoSQL-specific query operators** (like `$ne`, `$gt`, `$or`, etc.) to alter the logic of the query.

* **Example:** Injecting `{ "$ne": null }` to bypass authentication checks.

In this section, we'll explore how to identify and test for NoSQL injection vulnerabilities in general. Then, we'll dive deeper into **MongoDB**, the most widely used NoSQL database, to see how these attacks work in a real-world context.

### NoSQL Syntax Injection

**Syntax injection** in NoSQL happens when an attacker can break or manipulate the structure of a query using specially crafted input.

To identify this vulnerability, try submitting **fuzz strings** or **special characters** into different input fields and observe the application's response. If the input isn’t properly sanitized or filtered, you might see database errors or unusual behavior — which could be a sign of a potential injection point.

If you already know the target database (like MongoDB or CouchDB), you can tailor your input using **characters or patterns specific to that database's query syntax**. Otherwise, use a broad set of fuzz strings to cover multiple NoSQL languages and structures.

### Detecting syntax injection in MongoDB

Consider a shopping application that displays products in different categories. When the user selects the **Fizzy drinks** category, their browser requests the following URL:
```
https://insecure-website.com/product/lookup?category=fizzy
```
This causes the application to send a JSON query to retrieve relevant `products` from the product collection in the MongoDB database:
```
this.category == 'fizzy'
```
To test whether the input may be vulnerable, submit a fuzz string in the value of the `category` parameter. An example string for MongoDB is:
```
'"`{
;$Foo}
$Foo \xYZ
```

Use this fuzz string to construct the following attack:
```
https://insecure-website.com/product/lookup?category='%22%60%7b%0d%0a%3b%24Foo%7d%0d%0a%24Foo%20%5cxYZ%00
```

If this causes a change from the original response, this may indicate that user input isn't filtered or sanitized correctly.

> Note:
> 
> NoSQL injection vulnerabilities can occur in a variety of contexts, and you need to adapt your fuzz strings accordingly. Otherwise, you may simply trigger validation errors that mean the application never executes your query.
>
> In this example, we're injecting the fuzz string via the URL, so the string is URL-encoded. In some applications, you may need to inject your payload via a JSON property instead. In this case, this payload would become 
> `'\"``{\r;$Foo}\n$Foo\\xYZ\u0000`.

### Determining which characters are processed

To determine which characters are interpreted as syntax by the application, you can inject individual characters. For example, you could submit `'`, which results in the following MongoDB query:
```
this.category == '''
```
If this causes a change from the original response, this may indicate that the ' character has broken the query syntax and caused a syntax error. You can confirm this by submitting a valid query string in the input, for example by escaping the quote:
```
this.category == '\''
```
If this doesn't cause a syntax error, this may mean that the application is vulnerable to an injection attack.

### Confirming conditional behavior

After detecting a vulnerability, the next step is to determine whether you can influence boolean conditions using NoSQL syntax.

To test this, send two requests, one with a false condition and one with a true condition. For example you could use the conditional statements `' && 0 && 'x` and ' `&& 1 && 'x` `as follows:
```
https://insecure-website.com/product/lookup?category=fizzy'+%26%26+0+%26%26+'xhttps://insecure-website.com/product/lookup?category=fizzy'+%26%26+1+%26%26+'x
```
If the application behaves differently, this suggests that the false condition impacts the query logic, but the true condition doesn't. This indicates that injecting this style of syntax impacts a server-side query.

### Overriding existing conditions
Now that you have identified that you can influence boolean conditions, you can attempt to override existing conditions to exploit the vulnerability. For example, you can inject a JavaScript condition that always evaluates to true, such as `'||'1'=='1`:

```
https://insecure-website.com/product/lookup?category=fizzy%27%7c%7c%27%31%27%3d%3d%27%31
```
This results in the following MongoDB query:

```
this.category == 'fizzy'||'1'=='1'
```

As the injected condition is always true, the modified query returns all items. This enables you to view all the products in any category, including hidden or unknown categories.
> Note:
>
> Take care when injecting a condition that always evaluates to true into a NoSQL query. Although this may be harmless in the initial context you're injecting into, it's common for applications to use data from a single request in multiple different queries. If an application uses it when updating or deleting data, for example, this can result in accidental data loss.

---
| S.No | Name | Walkthrough |
|--|--|--|
| Lab 1 | [Detecting NoSQL injection](https://portswigger.net/web-security/nosql-injection/lab-nosql-injection-detection) | [Link](https://github.com/Esther7171/Web-Application-Penetration-Testing/blob/main/Wpt/Server%20Side%20vulnerability/NoSQL%20injection/Labs/Lab%201:%20Detecting%20NoSQL%20injection.md#lab1detecting-nosql-injection) |

---

### Bypassing Filters Using Null Character Injection

In some cases, you can use a **null byte (`%00`)** in the input to bypass server-side conditions. MongoDB may **ignore everything after a null character**, effectively truncating the rest of the query.

For example, consider the original MongoDB query used by the application:

```js
this.category == 'fizzy' && this.released == 1
```

The condition `this.released == 1` ensures that only *released* products are shown. Unreleased products would typically have `this.released == 0`.

An attacker can exploit this by injecting a null character (`%00`) after the category value, like so:

```
https://insecure-website.com/product/lookup?category=fizzy'%00
```

This translates into the following NoSQL query:

```js
this.category == 'fizzy'\u0000' && this.released == 1
```

Because the null character terminates the query prematurely, the condition `this.released == 1` is ignored. As a result, **all products in the "fizzy" category are displayed**, including those that have not yet been released.

## NoSQL operator injection
Here's a refined and more professional version of your paragraph, with improved clarity and flow:

---

### NoSQL Operator Injection

NoSQL databases, such as MongoDB, use **query operators** to define conditions that data must meet to be included in query results. These operators allow for flexible and complex querying. Common MongoDB query operators include:

* **`$where`** – Matches documents that satisfy a JavaScript expression.
* **`$ne`** – Matches documents where the value is **not equal** to a specified value.
* **`$in`** – Matches any value that appears **within a specified array**.
* **`$regex`** – Selects documents where the field matches a given **regular expression**.

Attackers can potentially exploit these operators by injecting them into user inputs. This can alter the logic of a NoSQL query to bypass controls or access unauthorized data. To test for this vulnerability, you can systematically inject various operators into input fields and observe the application’s responses for error messages, unusual behavior, or data leakage.

## Submitting query operators

In JSON messages, you can insert query operators as nested objects. For example, `{"username":"wiener"}` becomes `{"username":{"$ne":"invalid"}}`.

For URL-based inputs, you can insert query operators via URL parameters. For example, `username=wiener` becomes `username[$ne]=invalid`. If this doesn't work, you can try the following:

1. Convert the request method from `GET` to `POST`.
2. Change the `Content-Type` header to `application/json`.
3. Add JSON to the message body.
4. Inject query operators in the JSON.

> Note:
>
> You can use the [Content Type Converter](https://portswigger.net/bappstore/db57ecbe2cb7446292a94aa6181c9278) extension to automatically convert the request method and change a URL-encoded POST request to JSON.

## Detecting operator injection in MongoDB

Consider a vulnerable application that accepts a username and password in the body of a `POST` request:
```
{"username":"wiener","password":"peter"}
```
Test each input with a range of operators. For example, to test whether the username input processes the query operator, you could try the following injection:
```
{"username":{"$ne":"invalid"},"password":"peter"}
```
If the `$ne` operator is applied, this queries all users where the username is not equal to invalid.

If both the username and password inputs process the operator, it may be possible to bypass authentication using the following payload: 
```
{"username":{"$ne":"invalid"},"password":{"$ne":"invalid"}}
```
This query returns all login credentials where both the username and password are not equal to invalid. As a result, you're logged into the application as the first user in the collection.

To target an account, you can construct a payload that includes a known username, or a username that you've guessed. For example:
```
{"username":{"$in":["admin","administrator","superadmin"]},"password":{"$ne":""}}
```
---
| S.No | Name | Walkthrough |
|--|--|--|
| Lab 1 | [Exploiting NoSQL operator injection to bypass authentication](https://portswigger.net/web-security/nosql-injection/lab-nosql-injection-bypass-authentication) | [Link]() |

---
