# <div align="center">NoSQL Injection</div>
**NoSQL injection** is a type of security vulnerability that happens when an attacker can manipulate the way an application talks to a NoSQL database. This kind of injection can be dangerous because it lets attackers interfere with database queries in unexpected ways.

With NoSQL injection, an attacker might be able to:

* Bypass login systems or security checks
* View, change, or delete data they shouldn’t have access to
* Crash the system and cause downtime (denial of service)
* In some cases, even run malicious code on the server

Unlike traditional SQL databases (like MySQL or PostgreSQL), **NoSQL databases** don’t use the standard SQL language. They store data in different formats (like JSON or key-value pairs) and have more flexible, but less strict, query structures—making them a bit trickier to secure if developers aren’t careful.

![nosql-injection-graphic](https://github.com/user-attachments/assets/8f6936cd-2fea-443c-bd8b-a7a40d16b5ee)


### Types of NoSQL Injection

There are **two main types** of NoSQL injection attacks you should know about:

#### 1. **Syntax Injection**

This happens when an attacker is able to **break or modify the structure** of a NoSQL query to insert their own malicious code. It’s somewhat similar to traditional SQL injection in concept, but since NoSQL databases use different query formats and data structures, the actual attack methods can vary quite a bit.

* **Example:** Injecting custom JSON objects into a query to change how it behaves.

#### 2. **Operator Injection**

In this case, the attacker uses **NoSQL-specific query operators** (like `$ne`, `$gt`, `$or`, etc.) to alter the logic of the query.

* **Example:** Injecting `{ "$ne": null }` to bypass authentication checks.

In this section, we'll explore how to identify and test for NoSQL injection vulnerabilities in general. Then, we'll dive deeper into **MongoDB**, the most widely used NoSQL database, to see how these attacks work in a real-world context.

### NoSQL Syntax Injection

**Syntax injection** in NoSQL happens when an attacker can break or manipulate the structure of a query using specially crafted input.

To identify this vulnerability, try submitting **fuzz strings** or **special characters** into different input fields and observe the application's response. If the input isn’t properly sanitized or filtered, you might see database errors or unusual behavior — which could be a sign of a potential injection point.

If you already know the target database (like MongoDB or CouchDB), you can tailor your input using **characters or patterns specific to that database's query syntax**. Otherwise, use a broad set of fuzz strings to cover multiple NoSQL languages and structures.

### Detecting syntax injection in MongoDB

Consider a shopping application that displays products in different categories. When the user selects the Fizzy drinks category, their browser requests the following URL:
```
https://insecure-website.com/product/lookup?category=fizzy
```
This causes the application to send a JSON query to retrieve relevant products from the product collection in the MongoDB database:
```
this.category == 'fizzy'
```
To test whether the input may be vulnerable, submit a fuzz string in the value of the category parameter. An example string for MongoDB is:
```
'"`{
;$Foo}
$Foo \xYZ
```

Use this fuzz string to construct the following attack:
```
https://insecure-website.com/product/lookup?category='%22%60%7b%0d%0a%3b%24Foo%7d%0d%0a%24Foo%20%5cxYZ%00
```

If this causes a change from the original response, this may indicate that user input isn't filtered or sanitized correctly.

> Note:
> 
> NoSQL injection vulnerabilities can occur in a variety of contexts, and you need to adapt your fuzz strings accordingly. Otherwise, you may simply trigger validation errors that mean the application never executes your query.
>
> In this example, we're injecting the fuzz string via the URL, so the string is URL-encoded. In some applications, you may need to inject your payload via a JSON property instead. In this case, this payload would become 
> `'\"``{\r;$Foo}\n$Foo\\xYZ\u0000`.

### Determining which characters are processed
